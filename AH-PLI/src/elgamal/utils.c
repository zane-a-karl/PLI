#include "../../hdr/elgamal/utils.h"


/**
 * Reads from the file 'filename' and
 * takes the log_base2('sec_par')-th bignum
 * @param output bignum from ascii hex string
 * @param filename of file to parse
 * @return SUCCESS/FAILURE
 */
int
parse_hardcoded_bignum (
    BIGNUM      **output,
    int          sec_par,
    const char *filename)
{
    const int len = 2048;
    char *buf = calloc(len, sizeof(char));
    int c = 0;
    int r = 0;
    int i = 0;
    int sec_par_i = log_base2(sec_par);
    int buf_i = 0;
    FILE *fin = fopen(filename, "r");
    if (!fin) {	return general_error("Failed to open hardcoded input file"); }

    memset(buf, 0, len);
    do {
	c = fgetc(fin);
	if (isalnum(c)) {
	    if (i == sec_par_i) {
		do {
		    buf[buf_i++] = c;
		    c = fgetc(fin);
		} while(isalnum(c));
		r = BN_hex2bn(output, buf);
		if (!r) { return openssl_error("Failed to hex2bn hardcoded bignum"); }
		break;
	    } else {
		do {
		    c = fgetc(fin);
		} while(isalnum(c));
		i++;
	    }
	}
    } while (!feof(fin) && !ferror(fin));

    free(buf);
    r = fclose(fin);
    if (r == EOF) { return general_error("Failed to close hardcoded input file"); }
    return SUCCESS;
}

/**
 * Elliptic curve crypto uses 224 bits secpar for security, while vanilla elgamal uses 2048.
 * Similarly, it uses 160 for 1024 bit security. So that we have a more apples to apples
 * comparison during the benchmark we need a function like this to limit the size of the random
 * number generated by vanilla elgamal so that something like exponentiation isn't skewing our
 * benchmarking results.
 * @param the output
 * @param the field order
 * @param the level of security
 */
int
generate_ec_equivalent_random_number (
    BIGNUM **random_number,
    BIGNUM        *modulus,
    int            sec_par)
{
    int r;
    BN_CTX *ctx = BN_CTX_new();
    switch (sec_par) {
    case 1024:
	r = BN_rand_range_ex(*random_number, modulus, 160, ctx);
	break;
    case 2048:
	r = BN_rand_range_ex(*random_number, modulus, 224, ctx);
	break;
    default:
	r = BN_rand_range_ex(*random_number, modulus, sec_par, ctx);
	break;
    }
    if (!r) { return openssl_error("Failed to gen ec equivalent random number"); }

    BN_CTX_free(ctx);
    return SUCCESS;
}

/**
 * allocs space for and initializes fields in
 * GamalKeys structure
 * @param structure to hold the keys
 * @return SUCCESS/FAILURE
 */
int
elgamal_generate_keys (
    GamalKeys *keys,
    int     sec_par)
{
    int r;
    /* int is_safe = 1; */
    /* BIGNUM *add; */
    BN_CTX *ctx = BN_CTX_new();
    keys->pk = calloc(1, sizeof(struct GamalPk));
    keys->pk->generator = BN_new();
    keys->pk->modulus   = BN_new();
    keys->pk->mul_mask  = BN_new();
    keys->sk = calloc(1, sizeof(struct GamalSk));
    keys->sk->secret    = BN_new();
    /* add = BN_new(); */

    // Assume generator = 3
    // Doing this randomly each time takes forever
    r = BN_set_word(keys->pk->generator, 3ULL);
    if (!r) { return openssl_error("Failed to set generator"); }

    /**************Gen the field's prime modulus**************/
    /* Run openssl dhparam -text -out dhparams.pem -2 2048 */
    /* -2 means it's a safe prime */
    /* r = parse_modulus_from_dhparams_file(); */
    r = parse_hardcoded_bignum(&keys->pk->modulus, sec_par, "input/primes.txt");
    /* Generates safe prime modulus on the fly */
    /* Fails for large sec_par value due to low internal entropy */
    /* r = BN_set_word(add, 8ULL); */
    /* if (!r) { return openssl_error("Failed to set add"); } */
    /* r = BN_generate_prime_ex2(keys->pk->modulus, sec_par, is_safe, */
    /* 			       add, keys->pk->generator, NULL, ctx); */
    /* Get prime from https://bigprimes.org/ */
    /* r = BN_set_word(keys->pk->modulus, 172758658065239ULL); */
    if (!r) { return openssl_error("Failed to generate prime ex2"); }
    // Check if it's indeed prime
    r = BN_check_prime(keys->pk->modulus, ctx, NULL);
    if (!r) { return openssl_error("Failed to generate true prime"); }

    // Gen the field element secret key
    /* This will fail for high values of sec_par due to your computer having low entropy I guess */
    /* r = BN_rand_range_ex(keys->sk->secret, keys->pk->modulus, sec_par, ctx); */
    /* If you need things to not fail just grab one of the hardcoded values */
    r = parse_hardcoded_bignum(&keys->sk->secret, sec_par, "input/secret-keys.txt");
    if (!r) { return openssl_error("Failed to gen secret key"); }
    // Gen the field element mul_mask
    r = BN_mod_exp(keys->pk->mul_mask, keys->pk->generator,
		   keys->sk->secret, keys->pk->modulus, ctx);
    if (!r) { return openssl_error("Failed to calculate h = g^sk"); }

    /* BN_free(add); */
    BN_CTX_free(ctx);
    if (!r) {
	return FAILURE;
    }
    return SUCCESS;
}

/**
 * Computes res = a*b = (a.c1*b.c1, a.c2*b.c2)
 * @param resulting output
 * @param a input
 * @param b input
 * @return SUCCESS/FAILURE
 */
int
elgamal_mul (
    GamalCiphertext *res,
    GamalCiphertext    a,
    GamalCiphertext    b,
    BIGNUM      *modulus)
{
    int r = 1;
    BN_CTX *ctx = BN_CTX_new();
    res->c1 = BN_new();
    if (!res->c1) { r = 0; return openssl_error("Error allocating res->c1"); }
    res->c2 = BN_new();
    if (!res->c2) { r = 0; return openssl_error("Error allocating res->c2"); }
    // Calc a.c1 * b.c1
    r = BN_mod_mul(res->c1, a.c1, b.c1, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c1 * b.c1"); }
    // Calc a.c2 * b.c2
    r = BN_mod_mul(res->c2, a.c2, b.c2, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c2 * b.c2"); }

    BN_CTX_free(ctx);
    if (!r) {
	return FAILURE;
    }
    return SUCCESS;
}

/**
 * Computes res = a^r = (a.c1^r, a.c2^r)
 * @param resulting output
 * @param a input
 * @param exponent input
 * @return SUCCESS/FAILURE
 */
int
elgamal_exp (
    GamalCiphertext *res,
    GamalCiphertext    a,
    BIGNUM     *exponent,
    BIGNUM      *modulus)
{
    int r = 1;
    BN_CTX *ctx = BN_CTX_new();
    res->c1 = BN_new();
    if (!res->c1) { r = 0; return openssl_error("Error allocating res->c1"); }
    res->c2 = BN_new();
    if (!res->c2) { r = 0; return openssl_error("Error allocating res->c2"); }
    // Calc a.c1^r
    r = BN_mod_exp(res->c1, a.c1, exponent, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c1^r"); }
    // Calc a.c2^r
    r = BN_mod_exp(res->c2, a.c2, exponent, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c2^r"); }

    BN_CTX_free(ctx);
    if (!r) {
	return FAILURE;
    }
    return SUCCESS;
}

int
elgamal_permute_ciphertexts (
    GamalCiphertext **ctxts,
    unsigned long       len)
{
    int r;
    unsigned long rand;
    BIGNUM *bn_tmp_c1;
    BIGNUM *bn_tmp_c2;
    BIGNUM *bn_len;
    BIGNUM *bn_rand;
    BN_CTX *ctx = BN_CTX_new();
    bn_tmp_c1 = BN_new();
    bn_tmp_c2 = BN_new();
    bn_len = BN_new();
    bn_rand = BN_new();

    r = BN_set_word(bn_len, len);
    for (int i = 0; i < len; i++) {
	r = BN_rand_range(bn_rand, bn_len);
	if (!r) {return openssl_error("Failed bn_rand_range()"); }
	rand = BN_get_word(bn_rand);
	BN_copy(bn_tmp_c1, (*ctxts)[i].c1);
	BN_copy(bn_tmp_c2, (*ctxts)[i].c2);

	BN_copy((*ctxts)[i].c1, (*ctxts)[rand].c1);
	BN_copy((*ctxts)[i].c2, (*ctxts)[rand].c2);

	BN_copy((*ctxts)[rand].c1, bn_tmp_c1);
	BN_copy((*ctxts)[rand].c2, bn_tmp_c2);
    }
    BN_free(bn_tmp_c1);
    BN_free(bn_tmp_c2);
    BN_free(bn_len);
    BN_free(bn_rand);
    BN_CTX_free(ctx);
    return SUCCESS;
}

/**
 *
 */
int
evaluate_polynomial_at(
    BIGNUM   **share,
    BIGNUM *coeffs[],
    int        input,
    int    threshold,
    BIGNUM  *modulus)
{
    int r;
    BIGNUM *x;
    BN_CTX *ctx = BN_CTX_new();
    x = BN_new();
    r = BN_set_word(x, (unsigned long)input);
    if (!r) { return openssl_error("Failed to initialize input x"); }    
    *share = BN_dup(coeffs[threshold-1]);
    if (!(*share)) { return openssl_error("Failed to alloc share"); }    
    /* Stop before 0 so prevent undef behav */
    for (int i = threshold - 1; i > 0; i--) {
	r = BN_mod_mul(*share, *share, x            , modulus, ctx);
	if (!r) {return openssl_error("Failed share * x"); }	
	r = BN_mod_add(*share, *share, coeffs[i - 1], modulus, ctx);
	if (!r) {return openssl_error("Failed share + coeffs[i - 1]"); }	
    }
    BN_free(x);
    BN_CTX_free(ctx);
    return SUCCESS;
}

/**
 * Generates 'n'='num_shares' shares of 'secret' using a (t, n)-SSS Scheme ('t'='threshold').
 * Shares are created as poly(1..n+1)
 * @param Output array to hold shares
 * @param Secret to share
 * @param threshold
 * @param number of shares
 * @param group order
 */
int
elgamal_construct_shamir_shares (
    BIGNUM **shares,
    BIGNUM  *secret,
    int     sec_par,
    int   threshold,
    int  num_shares,
    BIGNUM *modulus)
{
    int r;
    BIGNUM *coeffs[threshold];
    BN_CTX *ctx = BN_CTX_new();

    coeffs[0] = BN_dup(secret);
    for (int i = 1; i < threshold; i++) {
	coeffs[i] = BN_new();
	if (!coeffs[i]) { return openssl_error("Failed to alloc coeffs"); }
	r = BN_rand_range_ex(coeffs[i], modulus, sec_par, ctx);
	if (!r) { return openssl_error("Failed to gen random coefficients"); }
    }
    for (int i = 0; i < num_shares; i++) {
	/* Fn alloc's shares[i] */
	r = evaluate_polynomial_at(&shares[i], coeffs, i + 1, threshold, modulus);
	if (!r) { return general_error("Failed evaluate_polynomial_at i+1"); }
    }

    BN_CTX_free(ctx);
    return SUCCESS;
}

int
try_reconstruct_with (
    BIGNUM **secret,
    BIGNUM      **x,
    BIGNUM      **y,
    int      length,
    BIGNUM *modulus)
{
    int r;
    BIGNUM *sum_accum;
    BIGNUM *mul_accum;
    BIGNUM *tmp;
    BN_CTX *ctx = BN_CTX_new();
    sum_accum = BN_new();
    mul_accum = BN_new();
    tmp = BN_new();
    BN_zero(sum_accum);
    for (int i = 0; i < length; i++) {
	BN_one(mul_accum);
	for (int j = 0; j < length; j++) {
	    if (i == j) {
		continue;
	    }
	    r = BN_mod_sub(tmp, x[j], x[i], modulus, ctx);
	    BN_mod_inverse(tmp, tmp, modulus, ctx);
	    r = BN_mod_mul(tmp, x[j], tmp, modulus, ctx);
	    r = BN_mod_mul(mul_accum, mul_accum, tmp, modulus, ctx);
	}
	r = BN_mod_mul(mul_accum, y[i], mul_accum, modulus, ctx);
	r = BN_mod_add(sum_accum, sum_accum, mul_accum, modulus, ctx);
    }
    if (!r) { return openssl_error("An error occurred be more specific"); }
    (*secret) = BN_dup(sum_accum);

    BN_free(sum_accum);
    BN_free(mul_accum);
    BN_free(tmp);
    BN_CTX_free(ctx);
    return SUCCESS;
}

int
manual_popcount (
    int input)
{
    int popcount = 0;
    int n = 8 * sizeof(int);
    for (int i = 0; i < n; i++) {
	if ( (input >> i) & 1 ) {
	    popcount++;
	}
    }
    return popcount;
}

/**
 * @param
 * @param the attempted reconstructed secret
 * @param the shares given
 * @param the threshold
 * @param the number of shares
 * @param the bitmask representing the index of the nCt combination of shares we are trying
 * @param the field order
 */
int
elgamal_reconstruct_shamir_secret (
    BIGNUM **secret,
    BIGNUM **shares,
    int   threshold,
    int  num_shares,
    int     bitmask,
    BIGNUM *modulus)
{
    int r;
    unsigned int n = num_shares;
    unsigned int t = threshold;
    unsigned long i;
    unsigned int save_i;
    BIGNUM *save_x[threshold];
    BIGNUM *save_y[threshold];
    BN_CTX *ctx = BN_CTX_new();
    for (i = 0; i < t; i++) {
	save_x[i] = BN_new();
	save_y[i] = BN_new();
    }
    save_i = 0;
    for (i = 0; i < n; i++) {
	/* printf("%i", (bitmask >> i) & 1); */
	if ((bitmask >> i) & 1) {
	    printf("%lu ", i);
	    BN_set_word(save_x[save_i], i + 1);
	    BN_copy(save_y[save_i], shares[i]);
	    save_i++;
	}
    }
    printf(": \n");
    for (int i = 0; i < save_i; i++) {
	printf("x = "); BN_print_fp(stdout, save_x[i]);
	printf(", y = "); BN_print_fp(stdout, save_y[i]); printf("\n");
    }
    /* Fn alloc's secret */
    r = try_reconstruct_with(secret, save_x, save_y, t, modulus);
    if (!r) { return openssl_error("Failed during try_reconstruct_with"); }
    for (i = 0; i < t; i++) {
	BN_free(save_x[i]);
	BN_free(save_y[i]);
    }
    BN_CTX_free(ctx);
    return SUCCESS;
}

int
elgamal_send_pk (
    int        sockfd,
    GamalPk       *pk,
    char *conf_prefix)
{
    int r;
    printf("%s\n", conf_prefix);
    r = send_msg(sockfd, pk->modulus, "\t- modulus   =", Bignum);
    if (!r) { return general_error("Failed to send modulus"); }
    r = send_msg(sockfd, pk->generator, "\t- generator =", Bignum);
    if (!r) { return general_error("Failed to send generator"); }
    r = send_msg(sockfd, pk->mul_mask, "\t- mul_mask  =", Bignum);
    if (!r) { return general_error("Failed to send mul_mask"); }
    return SUCCESS;
}

int
elgamal_send_ciphertext (
    int         sockfd,
    GamalCiphertext *c,
    char  *conf_prefix)
{
    int r;
    printf("%s\n", conf_prefix);
    r = send_msg(sockfd, c->c1, "\t- c1 = ", Bignum);
    if (!r) { return general_error("Failed to send ciphertext.c1"); }
    r = send_msg(sockfd, c->c2, "\t- c2 = ", Bignum);
    if (!r) { return general_error("Failed to send ciphertext.c2"); }
    return SUCCESS;
}

int
elgamal_send_shamir_shares (
    int         sockfd,
    BIGNUM    **shares,
    int     num_shares,
    char  *conf_prefix)
{
    int r;
    printf("%s\n", conf_prefix);
    for (int i = 0; i < num_shares; i++) {
	r = send_msg(sockfd, shares[i], "\t- share = ", Bignum);
	if (!r) { return general_error("Failed to send share"); }
    }
    return SUCCESS;
}

int
elgamal_recv_pk (
    int        sockfd,
    GamalPk       *pk,
    char *conf_prefix)
{
    int r;
    pk->modulus = BN_new();
    if (!pk->modulus) {r = 0; return openssl_error("Failed to alloc modulus");}
    pk->generator = BN_new();
    if (!pk->generator) {r = 0; return openssl_error("Failed to alloc generator");}
    pk->mul_mask = BN_new();
    if (!pk->mul_mask) {r = 0; return openssl_error("Failed to alloc mul_mask");}

    printf("%s\n", conf_prefix);
    r = recv_msg(sockfd, &pk->modulus, "\t- modulus   = ", Bignum);
    if (!r) { return general_error("Failed to recv modulus"); }
    r = recv_msg(sockfd, &pk->generator, "\t- generator = ", Bignum);
    if (!r) { return general_error("Failed to recv generator"); }
    r = recv_msg(sockfd, &pk->mul_mask, "\t- mul_mask  = ", Bignum);
    if (!r) { return general_error("Failed to recv mul_mask"); }

    return SUCCESS;
}

int
elgamal_recv_ciphertext (
    int         sockfd,
    GamalCiphertext *c,
    char  *conf_prefix)
{
    int r;
    c->c1 = BN_new();
    if (!c->c1) {r = 0; return openssl_error("Failed to alloc ciphertext c1");}
    c->c2 = BN_new();
    if (!c->c2) {r = 0; return openssl_error("Failed to alloc ciphertext c2"); }

    printf("%s\n", conf_prefix);
    r = recv_msg(sockfd, &c->c1, "\t- c1 = ", Bignum);
    if (!r) { return general_error("Failed to recv ciphertext c1"); }
    r = recv_msg(sockfd, &c->c2, "\t- c2 = ", Bignum);
    if (!r) { return general_error("Failed to recv ciphertext c2"); }

    return SUCCESS;
}
