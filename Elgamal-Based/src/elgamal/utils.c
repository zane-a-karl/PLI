#include <openssl/bn.h>                 // BIGNUM
#include <netdb.h>                      // struct sockaddr
#include "../../hdr/input-args/utils.h" // enum PartType
#include <openssl/ec.h>                 // EC_POINT
#include "../../hdr/macros.h"           // SUCCESS
#include "../../hdr/elgamal/utils.h"
#include "../../hdr/error/utils.h"   // general_error()
#include <ctype.h>		     // isalnum()
#include "../../hdr/network/utils.h" // send_msg()


/**
 * Reads from the file 'filename' and
 * takes the log_base2('sec_par')-th bignum
 * @param output bignum from ascii hex string
 * @param filename of file to parse
 * @return SUCCESS/FAILURE
 */
int
parse_hardcoded_bignum (
    BIGNUM      **output,
    int          sec_par,
    const char *filename)
{
    const int len = 2048;
    char *buf = calloc(len, sizeof(char));
    int c = 0;
    int r = 0;
    int i = 0;
    int sec_par_i = log_base2(sec_par);
    int buf_i = 0;
    FILE *fin = fopen(filename, "r");
    if (!fin) {	return general_error("Failed to open hardcoded input file"); }

    memset(buf, 0, len);
    do {
	c = fgetc(fin);
	if (isalnum(c)) {
	    if (i == sec_par_i) {
		do {
		    buf[buf_i++] = c;
		    c = fgetc(fin);
		} while(isalnum(c));
		r = BN_hex2bn(output, buf);
		if (!r) { return openssl_error("Failed to hex2bn hardcoded bignum"); }
		break;
	    } else {
		do {
		    c = fgetc(fin);
		} while(isalnum(c));
		i++;
	    }
	}
    } while (!feof(fin) && !ferror(fin));

    free(buf);
    r = fclose(fin);
    if (r == EOF) { return general_error("Failed to close hardcoded input file"); }

    return SUCCESS;
}

/**
 * Elliptic curve crypto uses 224 bits secpar for security, while vanilla elgamal uses 2048.
 * Similarly, it uses 160 for 1024 bit security. So that we have a more apples to apples
 * comparison during the benchmark we need a function like this to limit the size of the random
 * number generated by vanilla elgamal so that something like exponentiation isn't skewing our
 * benchmarking results.
 * @param the output
 * @param the field order
 * @param the level of security
 */
int
generate_ec_equivalent_random_number (
    BIGNUM **random_number,
    BIGNUM        *modulus,
    int            sec_par)
{
    int r;
    BN_CTX *ctx = BN_CTX_new();
    switch (sec_par) {
    case 1024:
	r = BN_rand_range_ex(*random_number, modulus, 160, ctx);
	break;
    case 2048:
	r = BN_rand_range_ex(*random_number, modulus, 224, ctx);
	break;
    default:
	r = BN_rand_range_ex(*random_number, modulus, sec_par, ctx);
	break;
    }
    if (!r) { return openssl_error("Failed to gen ec equivalent random number"); }

    BN_CTX_free(ctx);
    return SUCCESS;
}

/**
 * allocs space for and initializes fields in
 * GamalKeys structure
 * @param structure to hold the keys
 * @return SUCCESS/FAILURE
 */
int
elgamal_generate_keys (
    GamalKeys *keys,
    int     sec_par)
{
    int r;
    /* int is_safe = 1; */
    /* BIGNUM *add; */
    BN_CTX *ctx = BN_CTX_new();
    keys->pk = calloc(1, sizeof(struct GamalPk));
    keys->pk->generator = BN_new();
    keys->pk->modulus   = BN_new();
    keys->pk->mul_mask  = BN_new();
    keys->sk = calloc(1, sizeof(struct GamalSk));
    keys->sk->secret    = BN_new();
    /* add = BN_new(); */

    // Assume generator = 3
    // Doing this randomly each time takes forever
    r = BN_set_word(keys->pk->generator, 3ULL);
    if (!r) { return openssl_error("Failed to set generator"); }

    /**************Gen the field's prime modulus**************/
    /* Run openssl dhparam -text -out dhparams.pem -2 2048 */
    /* -2 means it's a safe prime */
    /* r = parse_modulus_from_dhparams_file(); */
    r = parse_hardcoded_bignum(&keys->pk->modulus, sec_par, "input/primes.txt");
    /* Generates safe prime modulus on the fly */
    /* Fails for large sec_par value due to low internal entropy */
    /* r = BN_set_word(add, 8ULL); */
    /* if (!r) { return openssl_error("Failed to set add"); } */
    /* r = BN_generate_prime_ex2(keys->pk->modulus, sec_par, is_safe, */
    /* 			       add, keys->pk->generator, NULL, ctx); */
    /* Get prime from https://bigprimes.org/ */
    /* r = BN_set_word(keys->pk->modulus, 172758658065239ULL); */
    if (!r) { return openssl_error("Failed to generate prime ex2"); }
    // Check if it's indeed prime
    r = BN_check_prime(keys->pk->modulus, ctx, NULL);
    if (!r) { return openssl_error("Failed to generate true prime"); }

    // Gen the field element secret key
    /* This will fail for high values of sec_par due to your computer having low entropy I guess */
    /* r = BN_rand_range_ex(keys->sk->secret, keys->pk->modulus, sec_par, ctx); */
    /* If you need things to not fail just grab one of the hardcoded values */
    r = parse_hardcoded_bignum(&keys->sk->secret, sec_par, "input/secret-keys.txt");
    if (!r) { return openssl_error("Failed to gen secret key"); }
    // Gen the field element mul_mask
    r = BN_mod_exp(keys->pk->mul_mask, keys->pk->generator,
		   keys->sk->secret, keys->pk->modulus, ctx);
    if (!r) { return openssl_error("Failed to calculate h = g^sk"); }

    /* BN_free(add); */
    BN_CTX_free(ctx);
    return SUCCESS;
}

/**
 * Computes res = a*b = (a.c1*b.c1, a.c2*b.c2)
 * @param resulting output
 * @param a input
 * @param b input
 * @return SUCCESS/FAILURE
 */
int
elgamal_mul (
    GamalCiphertext *res,
    GamalCiphertext    a,
    GamalCiphertext    b,
    BIGNUM      *modulus)
{
    int r;
    BN_CTX *ctx = BN_CTX_new();
    res->c1 = BN_new();
    if (!res->c1) { r = 0; return openssl_error("Error allocating res->c1"); }
    res->c2 = BN_new();
    if (!res->c2) { r = 0; return openssl_error("Error allocating res->c2"); }
    // Calc a.c1 * b.c1
    r = BN_mod_mul(res->c1, a.c1, b.c1, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c1 * b.c1"); }
    // Calc a.c2 * b.c2
    r = BN_mod_mul(res->c2, a.c2, b.c2, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c2 * b.c2"); }

    BN_CTX_free(ctx);
    return SUCCESS;
}

/**
 * Computes res = a^r = (a.c1^r, a.c2^r)
 * @param resulting output
 * @param a input
 * @param exponent input
 * @return SUCCESS/FAILURE
 */
int
elgamal_exp (
    GamalCiphertext *res,
    GamalCiphertext    a,
    BIGNUM     *exponent,
    BIGNUM      *modulus)
{
    int r;
    BN_CTX *ctx = BN_CTX_new();
    res->c1 = BN_new();
    if (!res->c1) { r = 0; return openssl_error("Error allocating res->c1"); }
    res->c2 = BN_new();
    if (!res->c2) { r = 0; return openssl_error("Error allocating res->c2"); }
    // Calc a.c1^r
    r = BN_mod_exp(res->c1, a.c1, exponent, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c1^r"); }
    // Calc a.c2^r
    r = BN_mod_exp(res->c2, a.c2, exponent, modulus, ctx);
    if (!r) { return openssl_error("Error calculating a.c2^r"); }

    BN_CTX_free(ctx);
    return SUCCESS;
}

int
elgamal_permute_ciphertexts (
    GamalCiphertext *ciphers,
    unsigned long        len)
{
    int r;
    unsigned long rand;
    BIGNUM *bn_tmp_c1;
    BIGNUM *bn_tmp_c2;
    BIGNUM *bn_len;
    BIGNUM *bn_rand;
    BN_CTX *ctx = BN_CTX_new();
    bn_tmp_c1 = BN_new();
    bn_tmp_c2 = BN_new();
    bn_len = BN_new();
    bn_rand = BN_new();

    r = BN_set_word(bn_len, len);
    for (int i = 0; i < len; i++) {
	r = BN_rand_range(bn_rand, bn_len);
	if (!r) { return openssl_error("Failed bn_rand_range()"); }
	rand = BN_get_word(bn_rand);
	BN_copy(bn_tmp_c1, ciphers[i].c1);
	BN_copy(bn_tmp_c2, ciphers[i].c2);

	BN_copy(ciphers[i].c1, ciphers[rand].c1);
	BN_copy(ciphers[i].c2, ciphers[rand].c2);

	BN_copy(ciphers[rand].c1, bn_tmp_c1);
	BN_copy(ciphers[rand].c2, bn_tmp_c2);
    }
    BN_free(bn_tmp_c1);
    BN_free(bn_tmp_c2);
    BN_free(bn_len);
    BN_free(bn_rand);
    BN_CTX_free(ctx);
    return SUCCESS;
}

int
elgamal_send_pk (
    int        sockfd,
    GamalPk       *pk,
    char *conf_prefix)
{
    int r;
    /* printf("%s\n", conf_prefix); */
    r = send_msg(sockfd, pk->modulus, "\t- modulus   =", Bignum);
    if (!r) { return general_error("Failed to send modulus"); }
    r = send_msg(sockfd, pk->generator, "\t- generator =", Bignum);
    if (!r) { return general_error("Failed to send generator"); }
    r = send_msg(sockfd, pk->mul_mask, "\t- mul_mask  =", Bignum);
    if (!r) { return general_error("Failed to send mul_mask"); }

    return SUCCESS;
}

int
elgamal_send_ciphertext (
    int         sockfd,
    GamalCiphertext *c,
    char  *conf_prefix)
{
    int r;
    /* printf("%s\n", conf_prefix); */
    r = send_msg(sockfd, c->c1, "\t- c1 = ", Bignum);
    if (!r) { return general_error("Failed to send ciphertext.c1"); }
    r = send_msg(sockfd, c->c2, "\t- c2 = ", Bignum);
    if (!r) { return general_error("Failed to send ciphertext.c2"); }

    return SUCCESS;
}

int
elgamal_send_shamir_shares (
    int         sockfd,
    BIGNUM    **shares,
    int     num_shares,
    char  *conf_prefix)
{
    int r;
    /* printf("%s\n", conf_prefix); */
    for (int i = 0; i < num_shares; i++) {
	r = send_msg(sockfd, shares[i], "\t- share = ", Bignum);
	if (!r) { return general_error("Failed to send share"); }
    }

    return SUCCESS;
}

int
elgamal_recv_pk (
    int        sockfd,
    GamalPk       *pk,
    char *conf_prefix)
{
    int r;
    pk->modulus = BN_new();
    if (!pk->modulus) {r = 0; return openssl_error("Failed to alloc modulus");}
    pk->generator = BN_new();
    if (!pk->generator) {r = 0; return openssl_error("Failed to alloc generator");}
    pk->mul_mask = BN_new();
    if (!pk->mul_mask) {r = 0; return openssl_error("Failed to alloc mul_mask");}

    /* printf("%s\n", conf_prefix); */
    r = recv_msg(sockfd, &pk->modulus, "\t- modulus   = ", Bignum);
    if (!r) { return general_error("Failed to recv modulus"); }
    r = recv_msg(sockfd, &pk->generator, "\t- generator = ", Bignum);
    if (!r) { return general_error("Failed to recv generator"); }
    r = recv_msg(sockfd, &pk->mul_mask, "\t- mul_mask  = ", Bignum);
    if (!r) { return general_error("Failed to recv mul_mask"); }

    return SUCCESS;
}

int
elgamal_recv_ciphertext (
    int         sockfd,
    GamalCiphertext *c,
    char  *conf_prefix)
{
    int r;
    c->c1 = BN_new();
    if (!c->c1) {r = 0; return openssl_error("Failed to alloc ciphertext c1");}
    c->c2 = BN_new();
    if (!c->c2) {r = 0; return openssl_error("Failed to alloc ciphertext c2"); }

    /* printf("%s\n", conf_prefix); */
    r = recv_msg(sockfd, &c->c1, "\t- c1 = ", Bignum);
    if (!r) { return general_error("Failed to recv ciphertext c1"); }
    r = recv_msg(sockfd, &c->c2, "\t- c2 = ", Bignum);
    if (!r) { return general_error("Failed to recv ciphertext c2"); }

    return SUCCESS;
}

/**
 *
 */
int
log_base2 (
    int sec_par)
{
    int result = -1;
    while (sec_par > 0) {
	sec_par >>= 1;
	result++;
    }
    return result;
}
