#include "../../hdr/protocols/tPLI-elgamal-mh.h"


extern uint64_t total_bytes;
static struct timespec t1,t2;
static double sec;
static FILE *logfs;
static char *logfile;

int
server_run_t_pli_elgamal_mh (
    int   new_fd,
    InputArgs ia)
{
    int r;
    int num_entries = 0;
    GamalKeys server_keys;
    GamalCiphertext *server_cipher;
    GamalCiphertext *client_cipher;
    BIGNUM **bn_plain;
    BN_CTX *ctx = BN_CTX_new();

    r = elgamal_generate_keys(&server_keys, ia.secpar);
    if (!r) { return openssl_error("Failed to gen EG keys"); }

    /* Start here to exclude key generation */
    TSTART(ia.secpar);

    r = parse_file_for_num_entries(&num_entries, ia.server_filename);
    if (!r) { return general_error("Failed to parse file for number of list entries"); }
    bn_plain = calloc(num_entries, sizeof(*bn_plain));
    for (int i = 0; i < num_entries; i++) {
	bn_plain[i] = BN_new();
	if (!bn_plain[i]) {r = 0; return openssl_error("Failed to alloc bn_plain"); }
    }
    r = parse_file_for_list_entries(bn_plain, num_entries, ia.server_filename);
    if (!r) { return general_error("Failed to parse file for list entries"); }

    r = elgamal_send_pk(new_fd, server_keys.pk, "Server sent:");
    if (!r) { return general_error("Failed to send server pk"); }

    server_cipher = calloc(num_entries, sizeof(*server_cipher));
    for (int i = 0; i < num_entries; i++) {
	r = elgamal_mh_encrypt(&server_cipher[i], *server_keys.pk, bn_plain[i], ia.secpar);
	if (!r) { return general_error("Failed to encrypt server plaintext"); }
	r = elgamal_send_ciphertext(new_fd, &server_cipher[i], "Server sent:");
	if (!r) { return general_error("Failed to send server ciphertext"); }
    }
    client_cipher = calloc(num_entries, sizeof(*client_cipher));
    for (int i = 0; i < num_entries; i++) {
	/* Server doesn't need c2 but to keep freeing consistent I've allocated it.
	   Can change this later if we want to optimize. */
	client_cipher[i].c1 = BN_new();
	client_cipher[i].c2 = BN_new();
	r = recv_msg(new_fd, &client_cipher[i].c1, "Server recv client ctxt.c1: ", Bignum);
	if (!r) { return general_error("Failed to recv client_ciphertext.c1"); }
    }

    /* Now do the following */
    /* 1. recv the AES encrytions */
    unsigned char **aes_cipher = calloc(num_entries, sizeof(*aes_cipher));
    size_t aes_cipher_lens[num_entries];
    unsigned char **iv = calloc(num_entries, sizeof(*aes_cipher));
    for (int i = 0; i < num_entries; i++) {
	iv[i] = calloc(EVP_MAX_IV_LENGTH, sizeof(unsigned char));
	r = recv_msg(new_fd, &iv[i], "Server recv iv:", UnsignedChar, EVP_MAX_IV_LENGTH);
	if (!r) { return general_error("Failed to recv iv for aes"); }
	r = recv_msg(new_fd, &aes_cipher_lens[i], "Server recv aes_ctxt_lens[i]:", SizeT);
	if (!r) { return general_error("Failed to recv aes ctxt lens"); }
	aes_cipher[i] = calloc(MAX_MSG_LEN, sizeof(unsigned char));
	r = recv_msg(new_fd, &aes_cipher[i], "Server recv aes_ctxt:", UnsignedChar,
		     aes_cipher_lens[i]);
	if (!r) { return general_error("Failed to recv aes ctxt"); }
    }
    /* 1.5 recv hash(s) */
    unsigned char *secret_digest = calloc(MAX_MSG_LEN, sizeof(unsigned char));
    r = recv_msg(new_fd, &secret_digest, "Server recv secret digest:", UnsignedChar, EVP_MAX_MD_SIZE);
    if (!r) { return general_error("Failed to recv secret digest"); }
    /* 2. decrypt the AES encryptions using hash(client_cipher[i].c1^sk) to get s'_i  */
    unsigned char *client_cipher_digests[num_entries];
    unsigned char *key;
    size_t digest_len;
    unsigned char **uchar_shares = calloc(num_entries, sizeof(*uchar_shares));
    BIGNUM *shares[num_entries];
    for (int i = 0; i < num_entries; i++) {
	/* BIG NOTE: I've stored ctxt[i].c1^sk into ctxt[i].c2, this is bad, but easier to code. */
	r = BN_mod_exp(client_cipher[i].c2, client_cipher[i].c1, server_keys.sk->secret,
		       server_keys.pk->modulus, ctx);
	if (!r) { return openssl_error("Failed to mod exp ctxt.c1^sk"); }

	switch (ia.secpar) {
	case 1024:
	    digest_len = SHA_DIGEST_LENGTH;
	    /* Fn alloc's client_cipher_digests[i] */
	    r = hash(&client_cipher_digests[i], client_cipher[i].c2, "SHA1", digest_len, Bignum);
	    break;
	case 2048:
	    digest_len = SHA256_DIGEST_LENGTH;
	    r = hash(&client_cipher_digests[i], client_cipher[i].c2, "SHA224", digest_len, Bignum);
	    break;
	default:
	    digest_len = SHA256_DIGEST_LENGTH;
	    r = hash(&client_cipher_digests[i], client_cipher[i].c2, "SHA256", digest_len, Bignum);
	    break;
	}
	if (!r) { return openssl_error("Failed to hash exp_res[i].c2"); }
	key = client_cipher_digests[i];
	printf("Keys ------>: ");
	for (int i = 0; i < digest_len; i++)
	    printf("%02x ", key[i]);
	printf("\n");
	r = symmetric_decrypt(&uchar_shares[i], aes_cipher[i], aes_cipher_lens[i],
			      key, iv[i], "AES-256-CTR", Bignum);
	if (!r) { return openssl_error("Failed to aes decrypt the shares"); }
	shares[i] = BN_new();
	BN_bin2bn(uchar_shares[i], strnlen((char *)uchar_shares[i], MAX_MSG_LEN), shares[i]);
	if (!shares[i]) { return openssl_error("Failed to bin2bn the uchar shares"); }
    }
    /* 3. reconstruct SSS's with the s'_i's to get s' */
    if (ia.threshold > num_entries || ia.threshold < 1) {
	return general_error("Failed to set meaningful threshold");
    }
    BIGNUM *possible_secret;
    unsigned char *possible_secret_digest;
    for (int mask = 0; mask < (1 << num_entries); mask++) {
	if (manual_popcount(mask) == ia.threshold) {
	    /* Fn alloc's possible_secret */
	    r = elgamal_reconstruct_shamir_secret(&possible_secret, shares, ia.threshold,
						  num_entries, mask, server_keys.pk->modulus);
	    if (!r) { return general_error("Failed to reconstruct shamir secret"); }
	    /* 4. hash s' and compare with the hash(s) you received */
	    switch (ia.secpar) {
	    case 1024:
		digest_len = SHA_DIGEST_LENGTH;
		/* Fn alloc's possible_secret_digest */
		r = hash(&possible_secret_digest, possible_secret, "SHA1", digest_len, Bignum);
		break;
	    case 2048:
		digest_len = SHA256_DIGEST_LENGTH;
		r = hash(&possible_secret_digest, possible_secret, "SHA224", digest_len, Bignum);
		break;
	    default:
		digest_len = SHA256_DIGEST_LENGTH;
		r = hash(&possible_secret_digest, possible_secret, "SHA256", digest_len, Bignum);
		break;
	    }
	    if (!r) { return openssl_error("Failed to hash poissble_secret"); }
	    /* printf("%i: \n", mask); */
	    printf("------------------\n");
	    for (int j = 0; j < digest_len; j++)
		printf("%02x ", secret_digest[j]);
	    printf("\n");
	    for (int j = 0; j < digest_len; j++)
		printf("%02x ", possible_secret_digest[j]);
	    printf("\n\n\n");
	    if (0 == memcmp(secret_digest, possible_secret_digest, digest_len)) {
		printf("SUCCESS :)\n");
		break;
	    }
	    BN_free(possible_secret);
	    free(possible_secret_digest);
	}
    }
    COLLECT_LOG_ENTRY(ia.secpar, ia.num_entries, ia.threshold, ia.expected_matches, total_bytes);

    BN_free(server_keys.pk->modulus);
    BN_free(server_keys.pk->generator);
    BN_free(server_keys.pk->mul_mask);
    free(server_keys.pk);
    BN_free(server_keys.sk->secret);
    free(server_keys.sk);
    for (int i = 0; i < num_entries; i++) {
	BN_free(client_cipher[i].c1);
	BN_free(client_cipher[i].c2);
	BN_free(server_cipher[i].c1);
	BN_free(server_cipher[i].c2);
	BN_free(bn_plain[i]);
    }
    free(bn_plain);
    free(server_cipher);
    free(client_cipher);
    BN_CTX_free(ctx);
    if (!r) {
	return FAILURE;
    }
    return SUCCESS;
}

int
client_run_t_pli_elgamal_mh (
    int   sockfd,
    InputArgs ia)
{
    int r;
    int num_entries = 0;
    GamalPk server_pk;
    GamalCiphertext *server_cipher;
    GamalCiphertext *client_cipher;
    BIGNUM **bn_plain;
    BN_CTX *ctx = BN_CTX_new();

    r = parse_file_for_num_entries(&num_entries, ia.client_filename);
    if (!r) { return general_error("Failed to parse file for number of list entries"); }

    /* Fn alloc's server_pk fields */
    r = elgamal_recv_pk(sockfd, &server_pk, "Client recv:");
    if (!r) { return general_error("Failed to recv server pk"); }

    server_cipher = calloc(num_entries, sizeof(*server_cipher));
    for (int i = 0; i < num_entries; i++) {
	/* Fn alloc's server_cipher[i].c1/c2 */
	r = elgamal_recv_ciphertext(sockfd, &server_cipher[i], "Client recv:");
	if (!r) { return general_error("Failed to recv server ciphertext"); }
    }

    bn_plain = calloc(num_entries, sizeof(*bn_plain));
    for (int i = 0; i < num_entries; i++) {
	bn_plain[i] = BN_new();
	if (!bn_plain[i]) {r = 0; return openssl_error("Failed to alloc bn_plain"); }
    }
    r = parse_file_for_list_entries(bn_plain, num_entries, ia.client_filename);
    if (!r) { return general_error("Failed to parse file for list entries"); }

    BIGNUM *bn_inv_plain[num_entries];
    for (int i = 0; i < num_entries; i++) {
	bn_inv_plain[i] = BN_mod_inverse(NULL, bn_plain[i], server_pk.modulus, ctx);
	if (!bn_inv_plain[i]) { r = 0; return openssl_error("Failed to invert bn_plain"); }
    }
    client_cipher = calloc(num_entries, sizeof(*client_cipher));
    for (int i = 0; i < num_entries; i++) {
	r = elgamal_mh_encrypt(&client_cipher[i], server_pk, bn_inv_plain[i], ia.secpar);
	if (!r) { return general_error("Error encrypting bn_inv_plain"); }
    }
    GamalCiphertext mul_res[num_entries];
    for (int i = 0; i < num_entries; i++) {
	/* mul_res alloc'd within fn */
	r = elgamal_mul(&mul_res[i], server_cipher[i], client_cipher[i], server_pk.modulus);
	if (!r) { return general_error("Failed to calc server_ciph * client_ciph"); }
    }
    BIGNUM *bn_rand_mask[num_entries];
    for (int i = 0; i < num_entries; i++) {
	bn_rand_mask[i] = BN_new();
	switch (ia.secpar) {
	case 1024:
	    r = BN_rand_range_ex(bn_rand_mask[i], server_pk.modulus, 160, ctx);
	    break;
	case 2048:
	    r = BN_rand_range_ex(bn_rand_mask[i], server_pk.modulus, 224, ctx);
	    break;
	default:
	    r = BN_rand_range_ex(bn_rand_mask[i], server_pk.modulus, ia.secpar, ctx);
	    break;
	}
	if (!r) { return openssl_error("Failed to gen rand_exp"); }
    }
    GamalCiphertext exp_res[num_entries];
    for (int i = 0; i < num_entries; i++) {
	/* exp_res alloc'd w/n fn */
	r = elgamal_exp(&exp_res[i], mul_res[i], bn_rand_mask[i], server_pk.modulus);
	if (!r) { return general_error("Failed to calculate cipher^mask"); }
	r = send_msg(sockfd, exp_res[i].c1, "Client sent exp_res[i].c1:", Bignum);
	if (!r) { return general_error("Failed to send exp_res[i].c1"); }
    }

    /* 1. generate a random secret value 's' */
    BIGNUM *bn_secret;
    bn_secret = BN_new();
    r = BN_rand_range_ex(bn_secret, server_pk.modulus, ia.secpar, ctx);
    if (!r) { return openssl_error("Failed to gen bn_secret"); }
    /* 2. secret share 's' using SSS to generate 'n' shares (s_i) */
    BIGNUM **shares = calloc(num_entries, sizeof(*shares));
    if (ia.threshold > num_entries || ia.threshold < 1) {
	return general_error("Failed to set meaningful threshold");
    }
    /* Fn alloc's num_entries shares */
    r = elgamal_construct_shamir_shares(shares, bn_secret, ia.secpar, ia.threshold,
					num_entries, server_pk.modulus);
    if (!r) { return general_error("Failed to construct shamir shares"); }
    unsigned char *uchar_shares[num_entries];
    for (int i = 0; i < num_entries; i++) {
	printf("Shares: ");
	uchar_shares[i] = calloc(BN_num_bytes(shares[i]), sizeof(unsigned char));
	BN_bn2bin(shares[i], uchar_shares[i]);
	if (!(uchar_shares + i)) { return openssl_error("Failed to bn2bin the shares"); }
	for (int j = 0; j < BN_num_bytes(shares[i]); j++)
	    printf("%02x ", uchar_shares[i][j]);
	printf("\n");
    }
    /* 3. hash (exp_res[i].c2) and store into exp_res_hashes[i] */
    unsigned char *exp_res_digests[num_entries];
    unsigned char *secret_digest;
    size_t digest_len;
    for (int i = 0; i < num_entries; i++) {
	switch (ia.secpar) {
	case 1024:
	    digest_len = SHA_DIGEST_LENGTH;
	    /* Fn alloc's exp_res_digests[i] */
	    r = hash(&exp_res_digests[i], exp_res[i].c2, "SHA1", digest_len, Bignum);
	    r &= hash(&secret_digest, bn_secret, "SHA1", digest_len, Bignum);
	    break;
	case 2048:
	    digest_len = SHA256_DIGEST_LENGTH;
	    r = hash(&exp_res_digests[i], exp_res[i].c2, "SHA224", digest_len, Bignum);
	    r &= hash(&secret_digest, bn_secret, "SHA224", digest_len, Bignum);
	    break;
	default:
	    digest_len = SHA256_DIGEST_LENGTH;
	    r = hash(&exp_res_digests[i], exp_res[i].c2, "SHA256", digest_len, Bignum);
	    r &= hash(&secret_digest, bn_secret, "SHA256", digest_len, Bignum);
	    break;
	}
	if (!r) { return openssl_error("Failed to hash exp_res[i].c2 or secret"); }
    }
    /* 4. Encrypt (s_i) with AES using arr[i] as key */
    unsigned char *key;
    unsigned char iv[num_entries][EVP_MAX_IV_LENGTH];
    unsigned char *ctxt_shares[num_entries];
    size_t ctxt_share_lens[num_entries];
    for (int i = 0; i < num_entries; i++) {
	key = exp_res_digests[i];
	printf("Keys ------>: ");
	for (int i = 0; i < digest_len; i++)
	    printf("%02x ", key[i]);
	printf("\n");
    redo:
	r = RAND_bytes(iv[i], EVP_MAX_IV_LENGTH);
	if (!r) { return openssl_error("Failed to gen random iv[i]"); }
	r = symmetric_encrypt(&ctxt_shares[i], &ctxt_share_lens[i], shares[i], key, iv[i],
			      "AES-256-CTR", Bignum);
	if (!r) { return openssl_error("Failed to aes encrypt the shares"); }
	if (ctxt_share_lens[i] < 8) { goto redo; }
	printf("Encrypted Shares: ");
	for (int j = 0; j < ctxt_share_lens[i]; j++)
	    printf("%02x ", ctxt_shares[i][j]);
	printf("\n");
	/* printf("ctxt_share_lens[%i] = %lu\n\n", i, ctxt_share_lens[i]); */
    }
    /* 5. send iv's, output of (4), and hash(s) to server */
    for (int i = 0; i < num_entries; i++) {
	r = send_msg(sockfd, iv[i], "Client sent iv:", UnsignedChar, EVP_MAX_IV_LENGTH);
	if (!r) { return general_error("Failed to send iv[i]"); }
	r = send_msg(sockfd, &ctxt_share_lens[i], "Client sent ctxt share len:", SizeT);
	if (!r) { return general_error("Failed to send ctxt_share_lens[i]"); }
	r = send_msg(sockfd, ctxt_shares[i], "Client sent ctxt share:", UnsignedChar,
		     ctxt_share_lens[i]);
	if (!r) { return general_error("Failed to send ciphertext_shares[i]"); }
    }
    /* printf("\n\nsecret digest length is %zu\n\n", digest_len); */
    r = send_msg(sockfd, secret_digest, "Client sent secret digest:", UnsignedChar, digest_len);
    if (!r) { return general_error("Failed to send secret digest"); }

    BN_free(server_pk.modulus);
    BN_free(server_pk.generator);
    BN_free(server_pk.mul_mask);
    for (int i = 0; i < num_entries; i++) {
	BN_free(server_cipher[i].c1);
	BN_free(server_cipher[i].c2);
	BN_free(bn_plain[i]);
	BN_free(bn_inv_plain[i]);
	BN_free(client_cipher[i].c1);
	BN_free(client_cipher[i].c2);
	BN_free(mul_res[i].c1);
	BN_free(mul_res[i].c2);
	BN_free(bn_rand_mask[i]);
	BN_free(exp_res[i].c1);
	BN_free(exp_res[i].c2);
    }
    free(server_cipher);
    free(bn_plain);
    free(client_cipher);
    BN_CTX_free(ctx);
    if (!r) {
	return FAILURE;
    }
    return SUCCESS;
}
